#include<stdio.h>

// 1.C 语言是接近底层的语言
// ·C 语言的程序在编译完后可以直接在机器上运行
// ·C 语言提供了一些较为底层的操作

// 按位运算（bitwise operation）
// ·C 语言有这样的运算符
// 	·&		按位的与
// 	·|		按位的或
// 	·~		按位取反
// 	·^		按位异或
// 	·<<		左移 			（*2或在右边补0）
// 	·>>		右移				（/2或抹去最后一位）

// 按位与&
// ·如果(x)i == 1 并且(y)i ==1, 那么(x  & y)i = 1
// ·否则的话(x  & y)i = 0
// ·按位与常用于两种应用：
// 	·让某一位或某些位为0：x  &  0xFE		(使得另一个数最低位变成0)
// 	·取一个数中的一段：x  &  0xFF		

// 按位或|
// ·如果(x)i == 1 或(y)i ==1, 那么(x | y)i = 1		
// ·否则的话(x | y)i = 0
// ·按位或常用于两种应用：
// 	·使得一位或几个位为1： x | 0x01		(使得另一个数最低位变成1)
// 	·把两个数拼起来： 0x00FF | 0xFF00

// 按位取反~
// ·(~x)i = 1 - (x)i
// ·把1 位变成0，0 位变成1
// ·想得到的全部位为1 的数：~0
// ·7 的二进制是0111，x | 7 使得低3 位为1 ，而
// ·x  &  ~7， 就使得低3 位为0

// 按位异或^
// ·如果(x)i == (y)i , 那么(x ^ y)i = 1	
// ·否则的话(x ^ y)i == 1
// ·如果两个位相等，那么结果为0；不相等，结果为1
// ·如果x 和y 相等， 那么x ^ y 的结果为0
// ·对一个变量用同一个值异或两次，等于什么也没做 （可以拿来做弱加密）
// ·x^y^y = x

// 逻辑运算vs 按位运算
// ·对于逻辑运算，它只看到两个值：0 和1
// ·可以认为逻辑运算相当于把所有非0 值都变成1，然后做按位运算
// ·5 & 4  =  4  而  5 && 4  ==  1 && 1 = 1
// ·5|4  =  5  而  5  ||  4  ==  1  ||  1 = 1
// ·~4  =  3  而  ！4  ==  ！1  =  0

// 2. 移位运算
// 左移<<
// ·i << j
// ·i 中所有位向左移到j 个位置，而右边填入0
// ·所有小于int 的类型，移位以int 的方式来做，结果是int，最多可以移的位数取决于int有多大
// ·x  <<=  1    等价于    x *= 2
// ·x  <<=  n    等价于    x *= 2^n
// ·左移过多会溢出变成0


// 右移>>
// ·i >> j
// ·i 中所有的位向右移j 位
// ·所有小于int 的类型，移位以int 的方式来做， 结果是int
// ·对于unsigned 的类型，左边填入0
// ·对于signed 的类型，左边填入原来的最高位（保持符号不变）
// ·x  >>=  1 等价于 x  /=  2
// ·x  >>=  n 等价于 x  /=  2^n


// NO ZUO NO DIE
// ·移位的位数不要用负数，这是没有定义的行为,不同编译器结果不同
// 	·x   <<   -2   	// NO!!

// 3.输出一个数的二进制
// ·见程序

// MCU 的SFR（特殊功能寄存器）
// （令某些比特为0 ，某些比特为1）
// ·const unsigned int SBS = 1u << 2;
// ·const unsigned int PE = 1u << 3;
// ·U0LCR  |=  SBS|PE;			(这两个比特同时做操作)
// ·U0LCR  &=  ~SBS;
// ·U0LCR  &=  ~( SBS| PE);

int main(int argc, char const* argv[])
{
	unsigned char c = 0xAA;

	printf(" c=%hhx\n", c);							//二进制源码
	printf("~c=%hhx\n", (char)~c);				//二进制反码
	printf("-c=%hhx\n", (char)-c);				//二进制补码

	unsigned char c = 0xA5;
	printf("   c=%x\n", c);
	printf("c<<2=%x\n\n", (int)c << 2);

	// shift operation
	int a = 0x80000000;
	int d = 0xC0000000;
	unsigned int b = 0x80000000;
	printf("a=%d\n", a);
	printf("b=%u\n", b);
	printf("d=%d\n", d);
	printf("a=%d\n", a>>1);
	printf("b=%u\n", b>>1);
	printf("d=%d\n", d >> 1);

	// 任意二、八、十六进制数转二进制
	int number;

	scanf("%i", &number);							//取十进制、十六进制或八进制类型的整数值
	unsigned mask = 1u << 31;						//把1向左移32位，移为0x80000000

	for (; mask; mask >>= 1) {
		printf("%d", number & mask ? 1 : 0);
	}
	printf("\n");

	return 0;
}