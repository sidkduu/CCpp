#include<stdio.h>
#include<stdlib.h>

// 1.scanf
// ·如果能够将取得的变量的地址传递给一个函数，能否通过这个地址在那个函数内访问这个变量？
// ·scanf（"%d",&i）;
// ·scanf ()的原型应该是怎样的？我们需要一个参数能保存别的变量的地址，
//  如何表达能够保存地址的变量？

// 指针就是保存地址的变量
// int i；
// int* p = &i；
// int*  p,q；(*p是指针，q是int)
// int  *p,*q；

// 指针变量
// ·变量的值是内存的地址
// ·普通的变量的值是实际的值
// ·指针变量的值是具有实际值的变量的地址

// 作为参数的指针
// ·void f(int *p);
// ·在被调用的时候得到了某个变量的地址：
//     ·int i = 0；f（&i）；
// ·在函数里面可以通过指针访问外面这个i；

// 访问那个地址上的变量*
// ·*是一个单目运算符，用来访问指针的值所表示的地址上的变量
// ·可以做右值可以做左值
// ·int k = *p；
// · *p = k + 1；

// 左值之所以叫左值
// ·是因为出现符号左边的不是变量，而是值，是表达式计算的结果：
// ·a[0] = 2;
// · *p = 3；
// ·是特殊的值，所以叫左值。

// 指针的运算符&*
// ·互相反作用
// *&yptr  ->  *(&yptr)  ->  *(yptr的地址)  ->  得到那个地址上的变量  ->  yptr
// &*yptr  ->  &(*yptr)  ->  &(y)  ->  得到y的地址，也就是yptr  ->  yptr

// 传入地址
// ·为什么
// ·int i； scanf("%d",i);
// ·如果scanf时忘记&，（32位架构）编译时没有报错，
// 但运行时报错（编译器认为把i的地址传进去（scanf把数字写到了不该写的地方））。

// 2.传入函数的数组组成了什么？
// ·函数参数表中的数组实际上是指针
// 	·sizeof(a) == sizeof(int*)
// 	·但是可以使用数组运算符[]进行运算。

// 数组参数
// ·以下四种函数的原型是等价的：
// 	·int  sum(int *ar，int n);
// 	·int sum(int*,  int);
// 	·int sum(int ar[],  int n);
// 	·int sum(int[],  int);

// 数组变量是特殊的指针
// ·数组变量本身表达地址，所以
// 	·int a[10];  int*p=a;   
// 	·但是数组的单元表达的是变量，需要&取地址
// 	·a == &a[0]
// 	·[]运算符可以对数组做，也可以对指针做：
// 		p[0]  <==>  a[0]
// 	·*运算符可以对指针做，也可以对数组做：
// 		*a = 25；
// 	·数组变量是const指针，数组变量是不能互相赋值的。
// 		int b[]  <-->  int  * const  b;

// 3.指针是const
// ·表示一旦得到了某个变量的地址，不能在指向其它变量
// 	·int * const q  =  &i;  //q是const
// 	· *q = 26；//OK
// 	· q++；//ERROR

// 所指的是const
// ·表示不能通过这个指针去修改那个变量（并不能使得那个变量成为const）
// 	·const  int  *p  =  &i;
// 	· *p  =  26;  //ERROR! (*p) 是 const
// 	· i = 26； // OK
// 	· p = &j； //OK

// int i;
// const  int* p1  =  &i;
// int  const*  p2  =  &i;
// int  *const  p3  =  &i;
// p1 和 p2 都是指向常量整数的指针，它们所指向的整数不能被修改，但指针本身可以被修改以指向其他整数。
// p3 是一个指向整数的常量指针，它不能被修改以指向其他整数，但可以通过它修改所指向的整数的值。

// 转换
// ·总是可以把一个非const的值转换成const的
//     	void  f(const  int * x);
// 	int a = 15;
// 	f(&a);		//OK
// 	const  int  b  =  a;

// 	f(&b);		//OK
// 	b = a + 1;	//ERROR!

// ·当要传递的参数的类型比较大的时候，这是常用的手段：既能用比较少的字节数传递值给参数，
//  又能避免函数对外面变量的修改。


// const 数组
// ·const int a[] = {1,2,3,4,5,6};
// ·数组变量已经是const的指针了，这里的const表明数组的每个单元都是const int
// ·所以必须通过初始化进行赋值


// 保护数组值
// ·因为把数组传入函数时传递的是地址，所以那个函数内部可以修改数组的值
// ·为了保护数组不被破坏，可以设置参数为const
// ·int sum（const int a[],  int length）;

// 4.·给一个指针加1表示要让指针指向下一个变量
// 	int a[10];
// 	int *p = a;
// 	*(p+1)  --> a[1]
// ·如果指针不是指向一片连续分配的空间，如数组，则这种运算没有意义

// 指针计算
// ·这些算术计算可以对指针做：
//   · 给指针加、减一个整数（+，+=，-，-=）
//   ·递增递减（++/--）
//   ·两个指针相减（subroutine1）


// 指针比较
// ·<,<=,==,>,>=,!=都可以对指针做
// ·比较它们在内存中的地址
// ·数组中的单元的地址肯定是线性递增的

// 0地址
// ·当然内存中有0地址，但是0地址通常是一个随便碰的地址
// ·所以你的指针不应该具有0值
// ·因此可以用0地址来表示特殊的事情：
//     ·返回的指针是无效的
//     ·指针没有被真正初始化（先初始化为0）
// ·NULL是一个预定定义的符号，表示0地址
//     ·有的编译器不愿意用0来表示0地址


// 指针的类型
// ·无论指向什么类型，所有指针大小都是一样的，因为都是地址
// ·但是指向不同类型的指针是不能直接互相赋值的
// ·这是为了避免用错指针
// · q = p（E0513）

// 指针的类型转换
// ·void* 表示不知道指向什么东西的指针
//   ·计算时与char*相同（但不相通）
// ·指针可以转换类型
//   ·int *p = &i；void*q = （void*）p；
// ·这并没有改变p所指的变量的类型，
//  而是让后人用不同的眼光通过p看它所指的变量
// ·我不再当你是int啦，我认为你就是个void！

// 用指针来做什么
// ·需要传入较大的数据时用作参数
// ·传入数组后对数组做操作
// ·函数返回不止一个结果
//   ·需要用函数来修改不止一个变量
// ·动态申请内存...

// 5.输入数据
// ·如果输入数据时，先告诉你个数，然后再输入，要记录每个数据
// ·C99可以用变量做数组定义的大小，C99之前呢？
// ·int  *a  =  （int*）malloc（n*sozeof（int））；

// malloc
// #include<stdlib.h>
// void* malloc(size_t size;
// ·向malloc申请的空间的大小是以字节为单位的
// ·返回的结果是void*，需要转换成自己需要的类型
// ·(int*)malloc(n*sizeof(int))

// 没空间了？
// ·如果申请失败则返回0，或者叫做null
// ·系统能给你多大空间？（Subroutine1）

// free（）
// ·把申请得来的空间还给“系统”
// ·申请过的空间，最终应该都要还
// 	·混出来的，迟早是都要还的
// ·只能申请来的空间的首地址

// 常见问题
// ·申请了没free --》长时间运行内存逐渐下降
// ·找不到合适的free时机
// ·free过了再free
// ·地址变过了，直接去free

void minmax(int *a, int len, int* max, int* min);

int main(void)
{
	int a[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 13, 14, 16, 17, 21, 23, 55, 97 };
	int min, max;
	printf("main sizeof(a) = %zu\n", sizeof(a));
	printf("main a=%p\n", a);

	minmax(a, sizeof(a) / sizeof(a[0]), &min, &max);
	printf("a[0]=%d\n", a[0]);
	printf("min=%d, max=%d\n", min, max);
	int* p = &min;
	printf("*p=%d\n", *p);
	printf("p[0] = %d\n", p[0]);
	printf("*a=%d\n", *a);

	// dynamic memory allocation
	int number;
	int* aa;
	int i;
	printf("输入数量：");
	scanf("%d", &number);
	//int a[number];
	aa = (int*)malloc(number * sizeof(int));

	for (i = 0; i < number; i++) {
		scanf("%d", aa+i);
	}
	for (i = number - 1; i >= 0; i--) {
		if(aa+i) printf("%d ", *(aa+i));
	}
	free(aa);

	return 0;
}

void minmax(int *a, int len, int* min, int* max)
{
	int i;
	printf("minmax sizeof(a) = %zu\n", sizeof(a));
	printf("main a=%p\n", a);
	a[0] = 1000;

	*min = *max = a[0];
	for (i = 1; i < len; i++) {
		if (a[i] < *min) {
			*min = a[i];
		}
		if (a[i] > *max) {
			*max = a[i];
		}
	}
}