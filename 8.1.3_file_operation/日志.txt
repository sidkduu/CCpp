二进制文件
·其实所有的文件最终都是二进制的
·文本文件无非是用最简单的方式可以读写文件
	·more 、tail
	·cat
	·vi
·二进制文件是需要专门的程序来读写的文件
·文本文件的输入输出是格式化，可能经过转码


文本vs 二进制
·Unix 喜欢用文本文件来做数据存储和程序配置
	·交互式终端的出现使得人们喜欢用文本和计算机“talk”
	·Unix 的shell 提供了一些读写文本的小程序
·Windows 喜欢用二进制文件
	·DOS 是草根文化，并不继承和熟悉Unix 文化
	·PC刚开始的时候能力有限，DOS的能力更有限，二进制更接近底层

·文本的优势是方便人们读写，而且跨平台
	·文本的缺点是程序输入输出要经过格式化，开销大
·二进制的缺点是人类读写困难，而且不跨平台
	·int的大小不一致，大小端问题...
	·二进制的优点是程序读写快（直接输入输出）


程序为什么要操作文件
·配置
	·Unix 用文本，Windows 用注册表
·数据
	·稍微有点量的数据都放在数据库了
·媒体
	·这个只能是二进制的
·现实是，程序通过第三方库来读写文件，很少直接读写二进制文件了


二进制读写
·size_t fread (void* restrict ptr, size_t size, size_t nitems, FILE* restrict stream);
	·要读的内存，内存的大小，有几个这样的内存，文件指针；
·size_t fwrite (const void* restrict ptr, size_t size, size_t nitems, FILE* restrict stream);
	·要写的内存，内存的大小，有几个这样的内存，文件指针；
·注意FILE 指针是最后一个参数
·返回的是成功读写的字节数


为什么nitem
·因为二进制文件的读写一般都是通过对一个结构变量的操作来进行的
·于是nitem就是用来说明这次读写几个结构变量！


在文件中定位
·long ftell(FILE* stream);
·int fseek(FILE* stream, long offset, int whence); 
	·SEEK_SET: 从头开始
	·SEEK_CUR: 从当前位置开始
	·SEEK_END: 从尾开始（倒过来）


可移植性
·这样的二进制文件不具有可移植性
·在int位32 位的机器上写成的数据文件无法直接在int为64位的机器上正确输出
·解决方案之一是放弃使用int，而是typedef 具有明确大小的类型
·更好的方案是用文本（虽然速度会变慢）
·时至今日，人们很少会用C 语言最底层的方式操作数据了，可以使用数据库或第三方库



